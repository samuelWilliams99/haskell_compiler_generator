%precode {
import Data.Maybe
import Data.Either
import Data.List
import Semantics
import Control.Arrow
import Data.HashMap.Strict hiding (empty, union)

handleStatements :: [Either SemanticsRule String] -> ([SemanticsRule], [String])
handleStatements stmts = aux stmts ""
  where
    aux [] _ = ([], [])
    aux ((Left rule):stmts) t = first (rule{ _semanticsRuleAstType=t }:) $ aux stmts t
    aux ((Right t):stmts) _ = second (union [t]) $ aux stmts t
}

%operators "->" "=>" "<-" "@" "," "*->" "*=>" "^->" "^=>"
%keywords "evaluating" "where" "restricting" "to" "case"
%linecomments "#"
%blockcomments "#[" "]#"
%separateidentitycase
%parsermap { (languageDefsParser:) }

%token
      codeBlock     { TokenCustom "CodeBlock" $$ }
      varExtra      { TokenCustom "Directive" "varextra" }
      stateExtra    { TokenCustom "Directive" "stateextra" }
      baseType      { TokenCustom "Directive" "basetype" }
      paramType     { TokenCustom "Directive" "paramtype" }
      astType       { TokenCustom "Directive" "asttype" }
      extension     { TokenCustom "Directive" "extension" }
      importsCode   { TokenCustom "Directive" "importscode" }
      preCode       { TokenCustom "Directive" "precode" }
      outputPreCode { TokenCustom "Directive" "outputprecode" }
      standardEnv   { TokenCustom "Directive" "standardenv" }

Main :: Extension Imports? PreCode? OutPreCode? SemanticsDef     { (v1, v2, v3, v4, v5) }

SemanticsDef :: BaseType+ ParamType*
                StateExtra VarExtra
                StandardEnv Stmts                                { uncurry (SemanticsDef (fromList v1) (fromList v2) v3 v4 v5) $ handleStatements v6 }

Extension :: extension identifier                                { v2 }

Imports :: importsCode codeBlock                                 { v2 }

PreCode :: preCode codeBlock                                     { v2 }

OutPreCode :: outputPreCode identifier                           { v2 }
            | outputPreCode codeBlock                            { v2 }

CodeBlock :: codeBlock { v1 } | identifier { v1 } | upperIdentifier { v1 }

BaseType :: baseType identifier stringLit                        { (v2, v3) }

ParamType :: paramType identifier identifier                     { (v2, v3) }

StateExtra :: stateExtra CodeBlock CodeBlock                     { (v2, v3) }
            | %empty                                             { ("()", "()") }

VarExtra :: varExtra CodeBlock                                   { v2 }
          | %empty                                               { "()" }

StandardEnv :: standardEnv CodeBlock                             { v2 }

Stmts :: AstType Stmt+                                           { (Right v1):v2 }

Stmt :: Rule                                                     { Left v1 }
      | AstType                                                  { Right v1 }

AstType :: astType upperIdentifier                               { v2 }

Rule :: case codeBlock "->" codeBlock Type Evals Where?          { uncurry (SemanticsRule v2 v4 False v5 "" v7) v6 }
      | case codeBlock "=>" codeBlock Type Evals Where?          { uncurry (SemanticsRule v2 v4 True v5 "" v7) v6 }

Type :: "@" stringLit                                            { SemanticsStaticBaseType v2 }
      | "@" codeBlock                                            { SemanticsStaticType v2 }
      | "@" identifier                                           { SemanticsVarType v2 }
      | %empty                                                   { SemanticsCommandType }

Evals :: evaluating Eval+ Restricts                              { (v2, v3) }
       | %empty                                                  { ([], []) }

Eval :: identifier "->"  identifier Type                         { SemanticsRuleDependency v1 v3 (RawSemanticsDepType v4) False SemanticsDepSingle }
      | identifier "*->" identifier Type                         { SemanticsRuleDependency v1 v3 (RawSemanticsDepType v4) False (SemanticsDepFold False) }
      | identifier "^->" identifier Type                         { SemanticsRuleDependency v1 v3 (RawSemanticsDepType v4) False (SemanticsDepFold True) }
      | codeBlock  "=>"  codeBlock  Type                         { SemanticsRuleDependency v1 v3 (RawSemanticsDepType v4) True  SemanticsDepSingle }
      | codeBlock  "*=>" codeBlock  Type                         { SemanticsRuleDependency v1 v3 (RawSemanticsDepType v4) True  (SemanticsDepFold False) }
      | codeBlock  "^=>" codeBlock  Type                         { SemanticsRuleDependency v1 v3 (RawSemanticsDepType v4) True  (SemanticsDepFold True) }

Restricts :: restricting Restrict+                               { v2 }
           | %empty                                              { [] }

Restrict :: identifier to identifier+(',')                       { SemanticsTypeRestriction v1 v3 }

Where :: where codeBlock                                         { v2 }
