module MainCodeGenerator (generateMainCode) where



generateMainCode :: String -> String -> String -> Bool -> String
generateMainCode parserModule semanticsModule ext hasIncludes = unlines $ [
    "module Main where",
    "import System.IO",
    "import System.Directory",
    "import System.Environment",
    "import System.FilePath.Posix",
    "import System.Console.GetOpt",
    "import System.Exit",
    "import Data.HashMap.Strict as Map",
    "import Data.List as List hiding (insert, delete)",
    "import Data.Ord",
    "import Data.Maybe (fromMaybe)",
    "import Data.Foldable (asum)",
    "import Data.Time",
    "import Data.Time.Format",
    "import " ++ parserModule,
    "import " ++ semanticsModule,
    "data Flag = Ext | Info | Verbose | Output String " ++ (if hasIncludes then "| Dep String " else "") ++ "deriving (Show, Eq)",
    "options :: [OptDescr Flag]",
    "options = [ Option ['e'] [\"ext\", \"extension\"] (NoArg Ext) \"input extension for this compiler\"",
    "          , Option ['v'] [\"verbose\"] (NoArg Verbose) \"extra output information\"",
    "          , Option ['i'] [\"info\"] (NoArg Info) \"information about this compiler\"",
    "          , Option ['o'] [\"output\", \"out\"] (ReqArg Output \"FILE\") \"output FILE\"",
    if hasIncludes then "          , Option ['d'] [\"dep\", \"dependency\"] (ReqArg Dep \"DIR\") \"dependency folder\" ]" else "          ]",
    "handleArgs :: [String] -> IO ([Flag], [String])",
    "handleArgs argv =",
    "    case getOpt Permute options argv of",
    "        (fs,args,[]) -> return (fs, args)",
    "        (_,_,errs) -> usageError errs",
    "usageError :: [String] -> IO a",
    "usageError errs = ioError (userError (concat errs ++ usageInfo header options))",
    "  where header = \"\\nUsage: " ++ ext ++ "compiler [OPTION...] FILE\"",
    "getOutputPath :: [Flag] -> Maybe String",
    "getOutputPath [] = Nothing",
    "getOutputPath ((Output s):fs) = Just s",
    "getOutputPath (_:fs) = getOutputPath fs",
    "logV :: Bool -> String -> IO ()",
    "logV False _ = return ()",
    "logV True s = do",
    "    t <- getZonedTime",
    "    let timeStamp = formatTime defaultTimeLocale \"%H:%M:%S\" t",
    "    putStrLn $ timeStamp ++ \" | \" ++ s"] ++
    includeLines [
    "getDepPaths :: [Flag] -> [String]",
    "getDepPaths [] = []",
    "getDepPaths ((Dep s):fs) = s:(getDepPaths fs)",
    "getDepPaths (_:fs) = getDepPaths fs"
    ] ++ [
    "main :: IO ()",
    "main = do",
    "    (flags, args) <- getArgs >>= handleArgs",
    "    if elem Ext flags then putStrLn \"Files in the form name." ++ ext ++ " are compiled to name.c\"",
    "    else if elem Info flags then putStrLn \"This compiler was automatically generated by a compiler generator written by Samuel Williams\\nhttps://github.com/samuelWilliams99/\"",
    "    else if length args /= 1 then usageError []",
    "    else runCompiler (head args) (getOutputPath flags) (elem Verbose flags)" ++ if hasIncludes then " (getDepPaths flags)" else "",
    "resultToIO :: Result a -> IO a",
    "resultToIO (Error e) = die e",
    "resultToIO (Result a) = return a"] ++
    if hasIncludes then hasIncludesCode ext else noIncludesCode ext
  where
    includeLines ls = if hasIncludes then ls else []

hasIncludesCode :: String -> [String]
hasIncludesCode ext = [
    "volatileStateFilterNames :: (String -> Bool) -> VolatileState -> VolatileState",
    "volatileStateFilterNames f vs = vs { _vars = filterWithKey (\\k _ -> f k) (_vars vs),",
    "                                     _staticFuncs = filterWithKey (\\(k, _) _ -> f k) (_staticFuncs vs) }",
    "getIncludeMap :: IncludeMapType -> (VolatileState -> VolatileState)",
    "getIncludeMap IncludeMapEverything vs = vs",
    "getIncludeMap (IncludeMapWhitelist ks) vs = volatileStateFilterNames (\\k -> elem k ks) vs",
    "getIncludeMap (IncludeMapBlacklist ks) vs = volatileStateFilterNames (\\k -> not $ elem k ks) vs",
    "getIncludeMap (IncludeMapRename ns) vs =",
    "    vs { _vars = foldrWithKey (\\k v m ->",
    "             if member k nm then Map.insert (nm ! k) v $ delete k m else m",
    "         ) vars vars",
    "       , _staticFuncs = foldrWithKey (\\(k, as) v m ->",
    "             if member k nm then Map.insert (nm ! k, as) v $ delete (k, as) m else m",
    "         ) funcs funcs",
    "       }",
    "  where",
    "    nm = fromList ns",
    "    vars = _vars vs",
    "    funcs = _staticFuncs vs",
    "computeIncludeMap :: IncludeMap -> (VolatileState -> VolatileState)",
    "computeIncludeMap (IncludeMap t Nothing) = getIncludeMap t",
    "computeIncludeMap (IncludeMap t (Just next)) = computeIncludeMap next . getIncludeMap t",
    "getRealPath :: [String] -> String -> IO String",
    "getRealPath deps path = do",
    "    paths' <- mapM (canonicalizePath . (</> (path -<.> " ++ show ext ++ "))) (\"\":deps)",
    "    let paths = nub paths'",
    "    exists <- mapM doesFileExist paths",
    "    let validPaths = fmap snd $ List.filter fst $ zip exists paths",
    "    if validPaths == [] then",
    "        die $ \"Could not find file \\\"\" ++ path ++ \"\\\"\"",
    "    else if length validPaths == 1 then do",
    "        return $ head validPaths",
    "    else",
    "        die $ \"Found multiple of same file:\\n\" ++ intercalate \"\\n\" validPaths",
    "runCompiler :: String -> Maybe String -> Bool -> [String] -> IO ()",
    "runCompiler inp mOutp verbose deps",
    "    | takeExtension inp /= \"." ++ ext ++ "\" = die \"Invalid file extension, must be ." ++ ext ++ "\"",
    "    | otherwise = do",
    "        let outp = fromMaybe (replaceExtension inp \"c\") mOutp",
    "        code <- compile verbose deps inp",
    "        logV verbose $ \"Writing code to \" ++ outp",
    "        writeFile outp code",
    "hasCycles :: HashMap String [String] -> Maybe [String]",
    "hasCycles m = asum $ fmap (aux []) (keys m)",
    "  where",
    "    aux visited k = if elem k visited then Just (k:visited) else asum $ fmap (aux (k:visited)) (m ! k)",
    "isIncludeReady :: [String] -> [String] -> Bool",
    "isIncludeReady inp outp = all (\\x -> elem x outp) inp",
    "getIncludeOrder :: HashMap String [String] -> Result [String]",
    "getIncludeOrder m = case hasCycles m of",
    "                        Just xs -> Error $ \"Cyclic includes found: \\n\" ++ indent (intercalate \" ->\\n\" xs)",
    "                        Nothing ->",
    "                            let ks = sortBy (comparing (length . (m !))) (keys m)",
    "                            in Result $ reverse $ aux [] ks []",
    "                      where",
    "                        aux ks' (k:ks) out =",
    "                            if isIncludeReady (m ! k) out then",
    "                                aux [] (ks' ++ ks) (k:out)",
    "                            else",
    "                                aux (ks' ++ [k]) ks out",
    "                        aux _ [] out = out",
    "showPath :: String -> Result a -> Result a",
    "showPath _ (Result a) = Result a",
    "showPath path (Error e) = Error $ path ++ \" =>\\n\" ++ indent e",
    "getParseTrees :: Bool -> [String] -> String -> [String] -> IO (HashMap String (ASTCommand, [(String, VolatileState -> VolatileState)]))",
    "getParseTrees verbose deps path visited = do",
    "    content <- readFile path",
    "    logV verbose $ \"Parsing \" ++ path",
    "    (syntax, includes) <- resultToIO $ showPath path $ runParser content",
    "    realIncludes <- mapM (\\(i, im) -> fmap (\\i' -> (i', computeIncludeMap im)) $ getRealPath deps i) includes",
    "    let newIncludes = List.filter (\\include -> not $ elem include (path:visited)) $ fmap fst realIncludes",
    "    ms <- mapM (\\p -> getParseTrees verbose deps p ([path] ++ newIncludes ++ visited)) newIncludes",
    "    return $ Map.insert path (syntax, realIncludes) $ unions ms",
    "removeGlobals :: HashMap a [Var b] -> HashMap a [Var b]",
    "removeGlobals m = fmap (pure . setScope . head) $ Map.filter ((>0) . length) $ fmap (List.filter ((/=(-1)) . _varScopeLevel)) m",
    "    where setScope v = v { _varScopeLevel = -1 }",
    "cleanVolitileState :: VolatileState -> VolatileState",
    "cleanVolitileState vs = vs { _vars = removeGlobals $ _vars vs, _staticFuncs = removeGlobals $ _staticFuncs vs }",
    "getSemantics :: [(String, ASTCommand, [(String, VolatileState -> VolatileState)])] -> Bool -> Int -> VolatileState -> HashMap String VolatileState -> PersistentState -> IO String",
    "getSemantics [] _ _ _ _ _ = return \"\"",
    "getSemantics ((p, cmd, includes):fs) verbose i def sm pState = do",
    "    let vStates = def:(fmap (\\(path, f) -> f (sm ! path)) includes)",
    "    let vState = mconcat vStates",
    "    logV verbose $ \"[\" ++ show i ++ \" of \" ++ show (i + length fs) ++ \"] Compiling \" ++ p",
    "    (c, SemanticsState pStateOut vStateOut _) <- resultToIO $ showPath p $ runSemantics (SemanticsState pState vState $ parseState \"\") cmd",
    "    let vStateOut' = cleanVolitileState vStateOut",
    "    c' <- getSemantics fs verbose (i+1) def (Map.insert p vStateOut' sm) pStateOut",
    "    return $ c ++ \"\\n\\n\" ++ c'",
    "compile :: Bool -> [String] -> String -> IO String",
    "compile verbose deps path = do",
    "    realPath <- getRealPath deps path",
    "    m <- getParseTrees verbose deps realPath []",
    "    logV verbose $ \"Finished parsing, found \" ++ show (size m) ++ \" files\"",
    "    includeOrder <- resultToIO $ getIncludeOrder $ fmap (fmap fst . snd) m",
    "    logV verbose \"Resolved dependencies\"",
    "    let includeOrder' = [(p, cmd, is) | p <- includeOrder, let (cmd, is) = m ! p]",
    "    (SemanticsState pState vState _) <- resultToIO rDefaultState",
    "    code <- getSemantics includeOrder' verbose 1 vState empty pState",
    "    logV verbose $ \"Finished compiling \" ++ show (size m) ++ \" files\"",
    "    let wrappedCode = \"int main() {\\n\" ++ indent code ++ \"\\n    return 0;\\n}\"",
    "    return $ _outPreCode ++ wrappedCode"
    ]

noIncludesCode :: String -> [String]
noIncludesCode ext = [
    "runCompiler :: String -> Maybe String -> Bool -> IO ()",
    "runCompiler inp mOutp verbose",
    "    | takeExtension inp /= \"." ++ ext ++ "\" = die \"Invalid file extension, must be ." ++ ext ++ "\"",
    "    | otherwise = do",
    "        let outp = fromMaybe (replaceExtension inp \"c\") mOutp",
    "        exists <- doesFileExist inp",
    "        if not exists then",
    "            die $ \"Could not find file \\\"\" ++ inp ++ \"\\\"\"",
    "        else do",
    "            content <- readFile inp",
    "            code <- resultToIO $ compile verbose content",
    "            logV verbose $ \"Writing code to \" ++ outp",
    "            writeFile outp code",
    "compile :: Bool -> String -> Result String",
    "compile verbose s = do",
    "    logV verbose \"Parsing file\"",
    "    syntax <- runParser s",
    "    defaultState <- rDefaultState",
    "    logV verbose \"Compiling file\"",
    "    (code, _) <- runSemantics defaultState syntax",
    "    let wrappedCode = \"int main() {\\n\" ++ indent code ++ \"\\n    return 0;\\n}\"",
    "    return $ _outPreCode ++ wrappedCode"
    ]