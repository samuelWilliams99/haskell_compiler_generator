module MainCodeGenerator (generateMainCode) where

generateMainCode :: String -> String -> String -> String
generateMainCode parserModule semanticsModule ext = unlines [
    "module Main where",
    "import System.IO",
    "import System.Directory",
    "import System.Environment",
    "import System.FilePath.Posix",
    "import System.Console.GetOpt",
    "import System.Exit",
    "import Data.HashMap.Strict hiding (filter)",
    "import Data.List hiding (insert)",
    "import Data.Ord",
    "import Data.Maybe (fromMaybe)",
    "import Data.Foldable (asum)",
    "import " ++ parserModule,
    "import " ++ semanticsModule,
    "data Flag = Ext | Info | Input String | Output String | Dep String deriving (Show, Eq)",
    "options :: [OptDescr Flag]",
    "options = [ Option ['e'] [\"ext\", \"extension\"] (NoArg Ext) \"input extension for this compiler\"",
    "          , Option [] [\"info\"] (NoArg Info) \"information about this compiler\"",
    "          , Option ['i', 'c'] [\"input\", \"code\"] (ReqArg Input \"FILE\") \"input FILE\"",
    "          , Option ['o'] [\"output\", \"out\"] (ReqArg Output \"FILE\") \"output FILE\"",
    "          , Option ['d'] [\"dep\", \"dependency\"] (ReqArg Dep \"DIR\") \"dependency folder\" ]",
    "handleArgs :: [String] -> IO ([Flag])",
    "handleArgs argv =",
    "    case getOpt Permute options argv of",
    "        (o@(_:_),[],[]) -> return o",
    "        (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))",
    "    where header = \"Usage: ic [OPTION...] files...\"",
    "getIOPaths :: [Flag] -> (String, Maybe String)",
    "getIOPaths [] = (\"\", Nothing)",
    "getIOPaths ((Input s):fs) = (s, snd $ getIOPaths fs)",
    "getIOPaths ((Output s):fs) = (fst $ getIOPaths fs, Just s)",
    "getIOPaths (_:fs) = getIOPaths fs",
    "getDepPaths :: [Flag] -> [String]",
    "getDepPaths [] = []",
    "getDepPaths ((Dep s):fs) = s:(getDepPaths fs)",
    "getDepPaths (_:fs) = getDepPaths fs",
    "main :: IO ()",
    "main = do",
    "    flags <- getArgs >>= handleArgs",
    "    if elem Ext flags then putStrLn \"Files in the form name." ++ ext ++ " are compiled to name.c\"",
    "    else if elem Info flags then putStrLn \"This compiler was automatically generated by a compiler generator written by Samuel Williams\"",
    "    else (uncurry runCompiler $ getIOPaths flags) (getDepPaths flags)",
    "getRealPath :: [String] -> String -> IO String",
    "getRealPath deps path = do",
    "    paths' <- mapM (canonicalizePath . (</> path)) (\"\":deps)",
    "    let paths = nub paths'",
    "    exists <- mapM doesFileExist paths",
    "    let validPaths = fmap snd $ filter fst $ zip exists paths",
    "    if validPaths == [] then",
    "        die $ \"Could not find file \\\"\" ++ path ++ \"\\\"\"",
    "    else if length validPaths == 1 then do",
    "        return $ head validPaths",
    "    else",
    "        die $ \"Found multiple of same file:\\n\" ++ intercalate \"\\n\" validPaths",
    "runCompiler :: String -> Maybe String -> [String] -> IO ()",
    "runCompiler inp mOutp deps",
    "    | takeExtension inp /= \"." ++ ext ++ "\" = die \"Invalid file extension, must be ." ++ ext ++ "\"",
    "    | otherwise = do",
    "        let outp = fromMaybe (replaceExtension inp \"c\") mOutp",
    "        code <- compile deps inp",
    "        writeFile outp code",
    "hasCycles :: HashMap String [String] -> Maybe [String]",
    "hasCycles m = asum $ fmap (aux []) (keys m)",
    "  where",
    "    aux visited k = if elem k visited then Just (k:visited) else asum $ fmap (aux (k:visited)) (m ! k)",
    "isIncludeReady :: [String] -> [String] -> Bool",
    "isIncludeReady inp outp = all (\\x -> elem x outp) inp",
    "getIncludeOrder :: HashMap String [String] -> Result [String]",
    "getIncludeOrder m = case hasCycles m of",
    "                        Just xs -> Error $ \"Cyclic includes found: \\n\" ++ indent (intercalate \" ->\\n\" xs)",
    "                        Nothing ->",
    "                            let ks = sortBy (comparing (length . (m !))) (keys m)",
    "                            in Result $ reverse $ aux [] ks []",
    "                      where",
    "                        aux ks' (k:ks) out =",
    "                            if isIncludeReady (m ! k) out then",
    "                                aux [] (ks' ++ ks) (k:out)",
    "                            else",
    "                                aux (ks' ++ [k]) ks out",
    "                        aux _ [] out = out",
    "resultToIO :: Result a -> IO a",
    "resultToIO (Error e) = die e",
    "resultToIO (Result a) = return a",
    "getParseTrees :: [String] -> String -> [String] -> IO (HashMap String (ASTCommand, [String]))",
    "getParseTrees deps path visited = do",
    "    content <- readFile path",
    "    (syntax, includes) <- resultToIO $ runParser content",
    "    realIncludes <- mapM (getRealPath deps) includes",
    "    let newIncludes = filter (\\include -> not $ elem include (path:visited)) realIncludes",
    "    ms <- mapM (\\p -> getParseTrees deps p ([path] ++ newIncludes ++ visited)) newIncludes",
    "    return $ insert path (syntax, realIncludes) $ unions ms",
    "getSemantics :: [(String, ASTCommand, [String])] -> VolatileState -> HashMap String VolatileState -> PersistentState -> Result String",
    "getSemantics [] _ _ _ = return \"\"",
    "getSemantics ((p, cmd, includes):fs) def sm pState = do",
    "    let vStates = def:(fmap (sm !) includes)",
    "    let vState = mconcat vStates",
    "    (c, SemanticsState pState' vState' _) <- runSemantics (SemanticsState pState vState $ parseState \"\") cmd",
    "    c' <- getSemantics fs def (insert p vState' sm) pState'",
    "    return $ c ++ \"\\n\\n\" ++ c'",
    "compile :: [String] -> String -> IO String",
    "compile deps path = do",
    "    realPath <- getRealPath deps path",
    "    m <- getParseTrees deps realPath []",
    "    includeOrder <- resultToIO $ getIncludeOrder $ fmap snd m",
    "    let includeOrder' = [(p, cmd, is) | p <- includeOrder, let (cmd, is) = m ! p]",
    "    (SemanticsState pState vState _) <- resultToIO rDefaultState",
    "    code <- resultToIO $ getSemantics includeOrder' vState empty pState",
    "    let wrappedCode = \"int main() {\\n\" ++ indent code ++ \"\\n    return 0;\\n}\"",
    "    return $ _outPreCode ++ wrappedCode"
    ]
