module MainCodeGenerator (generateMainCode) where

generateMainCode :: String -> String -> String -> String
generateMainCode parserModule semanticsModule ext = unlines [
    "module Main where",
    "import System.IO",
    "import System.Directory",
    "import System.Environment",
    "import System.FilePath.Posix",
    "import System.Console.GetOpt",
    "import Data.Maybe (fromMaybe)",
    "import " ++ parserModule,
    "import " ++ semanticsModule,
    "data Flag = Ext | Info | Input String | Output (Maybe String) deriving (Show, Eq)",
    "options :: [OptDescr Flag]",
    "options = [ Option ['e'] [\"ext\", \"extension\"] (NoArg Ext) \"input extension for this compiler\"",
    "          , Option [] [\"info\"] (NoArg Info) \"information about this compiler\"",
    "          , Option ['i', 'c'] [\"input\", \"code\"] (ReqArg Input \"FILE\") \"input FILE\"",
    "          , Option ['o'] [\"output\", \"out\"] (OptArg Output \"FILE\") \"output FILE\" ]",
    "handleArgs :: [String] -> IO ([Flag])",
    "handleArgs argv =",
    "    case getOpt Permute options argv of",
    "        (o@(_:_),[],[]  ) -> return o",
    "        (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))",
    "    where header = \"Usage: ic [OPTION...] files...\"",
    "getIOPaths :: [Flag] -> (String, Maybe String)",
    "getIOPaths [] = (\"\", Nothing)",
    "getIOPaths ((Input s):fs) = (s, snd $ getIOPaths fs)",
    "getIOPaths ((Output ms):fs) = (fst $ getIOPaths fs, ms)",
    "getIOPaths (_:fs) = getIOPaths fs",
    "main :: IO ()",
    "main = do",
    "    flags <- getArgs >>= handleArgs",
    "    if elem Ext flags then putStrLn \"Files in the form name." ++ ext ++ " are compiled to name.c\"",
    "    else if elem Info flags then putStrLn \"This compiler was automatically generated by a compiler generator written by Samuel Williams\"",
    "    else runCompiler $ getIOPaths flags",
    "runCompiler :: (String, Maybe String) -> IO ()",
    "runCompiler (inp, mOutp)",
    "    | takeExtension inp /= \"." ++ ext ++ "\" = putStrLn \"Invalid file extension, must be ." ++ ext ++ "\"",
    "    | otherwise = do",
    "        let outp = fromMaybe (replaceExtension inp \"c\") mOutp",
    "        exists <- doesFileExist inp",
    "        if not exists then putStrLn (\"No such file \\\"\" ++ inp ++ \"\\\"\") else do",
    "            content <- readFile inp",
    "            case compile content of",
    "                Error e -> putStrLn e",
    "                Result code -> writeFile outp code",
    "compile :: String -> Result String",
    "compile s = runParser s >>= runSemantics"
    ]
