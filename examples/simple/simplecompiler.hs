module Main where
import System.IO
import System.Directory
import System.Environment
import System.FilePath.Posix
import System.Console.GetOpt
import System.Exit
import Data.HashMap.Strict as Map
import Data.List as List hiding (insert, delete)
import Data.Ord
import Data.Maybe (fromMaybe)
import Data.Foldable (asum)
import Data.Time
import Data.Time.Format
import SimpleParser
import SimpleSemantics
data Flag = Ext | Info | Verbose | Output String deriving (Show, Eq)
options :: [OptDescr Flag]
options = [ Option ['e'] ["ext", "extension"] (NoArg Ext) "input extension for this compiler"
          , Option ['v'] ["verbose"] (NoArg Verbose) "extra output information"
          , Option ['i'] ["info"] (NoArg Info) "information about this compiler"
          , Option ['o'] ["output", "out"] (ReqArg Output "FILE") "output FILE"
          ]
handleArgs :: [String] -> IO ([Flag], [String])
handleArgs argv =
    case getOpt Permute options argv of
        (fs,args,[]) -> return (fs, args)
        (_,_,errs) -> usageError errs
usageError :: [String] -> IO a
usageError errs = ioError (userError (concat errs ++ usageInfo header options))
  where header = "\nUsage: simplecompiler [OPTION...] FILE"
getOutputPath :: [Flag] -> Maybe String
getOutputPath [] = Nothing
getOutputPath ((Output s):fs) = Just s
getOutputPath (_:fs) = getOutputPath fs
logV :: Bool -> String -> IO ()
logV False _ = return ()
logV True s = do
    t <- getZonedTime
    let timeStamp = formatTime defaultTimeLocale "%H:%M:%S" t
    putStrLn $ timeStamp ++ " | " ++ s
main :: IO ()
main = do
    (flags, args) <- getArgs >>= handleArgs
    if elem Ext flags then putStrLn "Files in the form name.simple are compiled to name.c"
    else if elem Info flags then putStrLn "This compiler was automatically generated by a compiler generator written by Samuel Williams\nhttps://github.com/samuelWilliams99/"
    else if length args /= 1 then usageError []
    else runCompiler (head args) (getOutputPath flags) (elem Verbose flags)
resultToIO :: Result a -> IO a
resultToIO (Error e) = die e
resultToIO (Result a) = return a
runCompiler :: String -> Maybe String -> Bool -> IO ()
runCompiler inp mOutp verbose
    | takeExtension inp /= ".simple" = die "Invalid file extension, must be .simple"
    | otherwise = do
        let outp = fromMaybe (replaceExtension inp "c") mOutp
        exists <- doesFileExist inp
        if not exists then
            die $ "Could not find file \"" ++ inp ++ "\""
        else do
            content <- readFile inp
            code <- compile verbose content
            logV verbose $ "Writing code to " ++ outp
            writeFile outp code
compile :: Bool -> String -> IO String
compile verbose s = do
    logV verbose "Parsing file"
    syntax <- resultToIO $ runParser s
    defaultState <- resultToIO $ rDefaultState
    logV verbose "Compiling file"
    (code, _) <- resultToIO $ runSemantics defaultState syntax
    let wrappedCode = "int main() {\n" ++ indent code ++ "\n    return 0;\n}"
    return $ _outPreCode ++ wrappedCode
