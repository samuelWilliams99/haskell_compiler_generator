%export { ASTCommand (..), ASTExpr (..), ASTDecl (..) }
%precode {
data ASTCommand = ASTAssign String ASTExpr ParseState
                | ASTCall String [ASTExpr] ParseState
                | ASTIf ASTExpr ASTCommand ASTCommand ParseState
                | ASTWhile ASTExpr ASTCommand ParseState
                | ASTLet [ASTDecl] ASTCommand ParseState
                | ASTSeq [ASTCommand] ParseState
                | ASTPass ParseState

data ASTExpr = ASTExprBinOp String ASTExpr ASTExpr ParseState
             | ASTExprInt Int ParseState
             | ASTExprBool Bool ParseState
             | ASTExprVar String ParseState
             | ASTExprUnOp String ASTExpr ParseState

data ASTDecl = ASTDeclConst String ASTExpr ParseState
             | ASTDeclVar String (Maybe ASTExpr) ParseState

unwrapOp :: TokenType -> String
unwrapOp (TokenOperator s) = s
}
%operators "^" "*" "/" "+" "-" "<" "<=" "==" "!=" ">=" ">" "&&" "||" "!" "," ";" ":" ":=" "="
%keywords "begin" "const" "do" "else" "end" "if" "in" "let" "then" "var" "while" "true" "false" "pass" "include"
%linecomments "//"

%right "^"
%left "*" "/"
%left "+" "-"
%left "<" "<=" "==" "!=" ">=" ">"
%left "&&"
%left "||"

Root :: Include* Command { (v2, v1) }

Include :: include stringLit { v2 }

Command :: identifier ":=" Expression                         { ASTAssign v1 v3 ps1 }
         | identifier "(" Expression+(",") ")"                { ASTCall v1 v3 ps1 }
         | if Expression then Command else Command            { ASTIf v2 v4 v6 ps1 }
         | while Expression do Command                        { ASTWhile v2 v4 ps1 }
         | let Declaration+(";") in Command                   { ASTLet v2 v4 ps1 }
         | begin Command+(";") end                            { ASTSeq v2 ps1 }
         | pass                                               { ASTPass ps1 }

Expression :: PrimaryExpression                               { v1 }
            | Expression "^" Expression                       { ASTExprBinOp "^" v1 v3 ps2 }
            | Expression BinOp2 Expression %prec "*"          { ASTExprBinOp (unwrapOp v2) v1 v3 ps2 }
            | Expression BinOp3 Expression %prec "+"          { ASTExprBinOp (unwrapOp v2) v1 v3 ps2 }
            | Expression BinOp4 Expression %prec "<"          { ASTExprBinOp (unwrapOp v2) v1 v3 ps2 }
            | Expression "&&" Expression                      { ASTExprBinOp "&&" v1 v3 ps2 }
            | Expression "||" Expression                      { ASTExprBinOp "||" v1 v3 ps2 }

BinOp2 :: "*" { v1 } | "/" { v1 }
BinOp3 :: "+" { v1 } | "-" { v1 }
BinOp4 :: "<" { v1 } | "<=" { v1 } | "==" { v1 } | "!=" { v1 } | ">=" { v1 } | ">" { v1 }

PrimaryExpression :: integerLit                               { ASTExprInt v1 ps1 }
                   | identifier                               { ASTExprVar v1 ps1 }
                   | true                                     { ASTExprBool True ps1 }
                   | false                                    { ASTExprBool False ps1 }
                   | UnOp PrimaryExpression                   { ASTExprUnOp (unwrapOp v1) v2 ps1 }
                   | "(" Expression ")"                       { v2 }

UnOp :: "-" { v1 } | "!" { v1 }

Declaration :: const identifier "=" Expression { ASTDeclConst v2 v4 ps1 }
             | var identifier                  { ASTDeclVar v2 Nothing ps1 }
             | var identifier ":=" Expression  { ASTDeclVar v2 (Just v4) ps1 }
